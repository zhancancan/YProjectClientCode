using edit.pure.machine.core;
using game.pure.entity.scene.machine;

namespace plugins.machine.canvas.scene.actions {
    [MacActon(false, "Clear/Data", new[] {typeof (SceneMachineChart)})]
    internal class EtScAct_ClearData : Mac_Action {
        public override string actionType { get { return SceneMachineType.CLEAR_DATA; } }
        public override string renderContent { get { return "Clear Data"; } set { } }
    }

    [MacActon(false, "Clear/Entity", new[] {typeof (SceneMachineChart)})]
    internal class EtScAct_ClearEntity : Mac_Action {
        public override string actionType { get { return SceneMachineType.CLEAR_ENTITY; } }
        public override string renderContent { get { return "Clear Entity"; } set { } }
    }

    [MacActon(false, "Clear/Dispose Previous Scene", new[] {typeof (SceneMachineChart)})]
    internal class EtScAct_DisposePrev : Mac_Action {
        public override string actionType { get { return SceneMachineType.DISPOSE_PREV; } }
        public override string renderContent { get { return "Dispose previous scene"; } set { } }
    }

    [MacActon(false, "Clear/Final Dispose", new[] {typeof (SceneMachineChart)})]
    internal class EtScAct_FinalDispose : Mac_Action {
        public override string actionType { get { return SceneMachineType.FINAL_DISPOSE; } }
        public override string renderContent { get { return "Final Dispose"; } set { } }
    }

    [MacActon(false, "Clear/Clear Memory", new[] {typeof (SceneMachineChart)})]
    internal class EtScAct_ClearMemory : Mac_Action {
        public override string actionType { get { return SceneMachineType.CLEAR_MEMORY; } }
        public override string renderContent { get { return "Clear Memory"; } set { } }
    }
}